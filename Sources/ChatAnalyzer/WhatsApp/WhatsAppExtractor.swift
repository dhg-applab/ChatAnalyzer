//
//  WhatsAppExtractor.swift
//  
//
//  Created by Junpeng Chen on 27.07.23.
//

import Foundation
import os.log

class WhatsAppExtractor: ChatExtractor {
    let chatDataURL: URL
    var metadata: WhatsAppMetadata
    
    init(chatDataURL: URL) throws {
        if !chatDataURL.hasDirectoryPath {
            throw ChatExtractorError.directoryNotExist
        }
        self.chatDataURL = chatDataURL
        self.metadata = WhatsAppMetadata()
    }
    
    func extractChatData() throws -> WhatsAppChatData {
        do {
            let messages = try readChatFile()
            var chatMessages = [any ChatMessage]()
            for message in messages {
                do {
                    let chatMessage = try processMessage(message)
                    self.metadata.numberOfMessages += 1
                    chatMessages.append(chatMessage)
                } catch ChatExtractorError.autoGeneratedMessage {
                    continue
                } catch ChatExtractorError.messageNotValid {
                    os_log("Invalid message: %@", type: .error, message)
                    throw ChatExtractorError.messageNotValid
                } catch ChatExtractorError.attachmentNotSupported {
                    os_log("Not supported attachment found in message: %@", type: .error, message)
                    throw ChatExtractorError.attachmentNotSupported
                } catch {
                    os_log("Failed to parse message: %@", type: .error, error.localizedDescription)
                    throw error
                }
            }
            self.metadata.numberOfUsers = Set(chatMessages.map { $0.user }).count
            return WhatsAppChatData(messages: chatMessages, metadata: self.metadata)
        } catch {
            os_log("Failed to read chat file", type: .debug)
            throw ChatExtractorError.readChatFileFailed
        }
    }

    func readChatFile() throws -> [String] {
        let chatFileURL = self.chatDataURL.appendingPathComponent(WhatsAppConstants.chatFileName)
        let fileContent = try String(contentsOf: chatFileURL)
        
        // Remove all occurrences of U+200E, U+202A and U+202C
        let cleanedScalars = fileContent.unicodeScalars.filter { scalar in
            let scalarValue = scalar.value
            return scalarValue != 0x200E && scalarValue != 0x202A && scalarValue != 0x202C
        }
        let cleanedFileContent = String(String.UnicodeScalarView(cleanedScalars))
        
        // Split file content into messages
        let lines = cleanedFileContent.split(omittingEmptySubsequences: true, whereSeparator: { $0.isNewline })
        var messages = [String]()
        var messageLines = [String]()
        for line in lines {
            if line.starts(with: "["), !messageLines.isEmpty {
                messages.append(messageLines.joined(separator: "\n"))
                messageLines.removeAll()
            }
            messageLines.append(String(line))
        }
        if !messageLines.isEmpty {
            messages.append(messageLines.joined(separator: "\n"))
        }
        
        return messages
    }
    
    func processMessage(_ message: String) throws -> any ChatMessage {
        let (user, timestamp, chatMessage) = try parseMessage(from: message)
        
        // Ignore auto-generated messages by WhatsApp
        if isAutoGeneratedMessage(chatMessage) {
            throw ChatExtractorError.autoGeneratedMessage
        }
        
        if chatMessage.hasPrefix(WhatsAppConstants.attachmentPrefix) && chatMessage.hasSuffix(WhatsAppConstants.attachmentSuffix) {
            let (attachment, attachmentExtension, messageType) = try parseAttachment(from: chatMessage)
            return WhatsAppAttachment(user: user, timestamp: timestamp, messageType: messageType, attachment: attachment, attachmentExtension: attachmentExtension)
        } else if chatMessage == WhatsAppConstants.viewOncePhotoText {
            self.metadata.numberOfViewOncePhotos += 1
            return TextMessage(user: user, timestamp: timestamp, messageType: .viewOncePhoto, message: chatMessage, sentimentLabel: nil)
        } else if chatMessage == WhatsAppConstants.viewOnceVideoText {
            self.metadata.numberOfViewOnceVideos += 1
            return TextMessage(user: user, timestamp: timestamp, messageType: .viewOnceVideo, message: chatMessage, sentimentLabel: nil)
        } else if let fileMatch = try WhatsAppConstants.filePattern.wholeMatch(in: chatMessage) {
            let (filename, fileURL) = try parseFileMessage(fileMatch: fileMatch)
            self.metadata.numberOfFiles += 1
            return FileMessage(user: user, timestamp: timestamp, messageType: .file, filename: filename, fileURL: fileURL)
        } else if let locationMatch = try WhatsAppConstants.locationPattern.wholeMatch(in: chatMessage) {
            self.metadata.numberOfLocations += 1
            return WhatsAppLocationMessage(user: user, timestamp: timestamp, messageType: .location,
                                           location: String(locationMatch.1), city: String(locationMatch.2),
                                           latitude: String(locationMatch.3), longitude: String(locationMatch.4))
        } else if let pollMatch = try WhatsAppConstants.pollPattern.wholeMatch(in: chatMessage) {
            let (question, options) = try parsePollMessage(pollMatch: pollMatch)
            self.metadata.numberOfPolls += 1
            return WhatsAppPollMessage(user: user, timestamp: timestamp, messageType: .poll, question: question, options: options)
        } else {
            self.metadata.numberOfTexts += 1
            self.metadata.numberOfEmojis += message.emojiCount
            return TextMessage(user: user, timestamp: timestamp, messageType: .text, message: chatMessage, sentimentLabel: nil)
        }
    }

    func parseMessage(from message: String) throws -> (user: String, timestamp: Date, chatMessage: String) {
        // Parse timestamp
        guard let timestampRange = message.range(of: "] ") else {
            throw ChatExtractorError.messageNotValid
        }
        let formatter = DateFormatter()
        formatter.dateFormat = WhatsAppConstants.dateFormat
        guard let timestamp = formatter.date(from: String(message[message.startIndex..<timestampRange.upperBound])) else {
            throw ChatExtractorError.messageNotValid
        }
        
        // Parse user and message
        let userMessage = String(message[timestampRange.upperBound...])
        guard let userRange = userMessage.range(of: ": ") else {
            throw ChatExtractorError.messageNotValid
        }
        let user = String(userMessage[userMessage.startIndex..<userRange.lowerBound])
        let chatMessage = String(userMessage[userRange.upperBound...])

        return (user, timestamp, chatMessage)
    }

    private func isAutoGeneratedMessage(_ message: String) -> Bool {
        WhatsAppConstants.autoGeneratedMessages.contains(message)
    }
    
    private func parseAttachment(from message: String) throws -> (attachment: String, attachmentExtension: String, messageType: MessageType) {
        let attachmentStart = message.index(message.startIndex, offsetBy: 11)
        let attachmentEnd = message.index(message.endIndex, offsetBy: -1)
        let attachment = String(message[attachmentStart..<attachmentEnd])
        
        guard let dotIndex = attachment.lastIndex(of: ".") else {
            throw ChatExtractorError.messageNotValid
        }
        let attachmentExtension = String(attachment[attachment.index(after: dotIndex)...]).lowercased()
        
        let messageType: MessageType
        switch attachmentExtension {
        case "webp":
            messageType = .sticker
            self.metadata.numberOfStickers += 1
        case "jpg", "jpeg", "png":
            messageType = .photo
            self.metadata.numberOfPhotos += 1
        case "opus":
            messageType = .voiceMessage
            self.metadata.numberOfVoiceMessages += 1
        case "mp4", "mov":
            messageType = .video
            self.metadata.numberOfVideos += 1
        case "vcf":
            messageType = .contact
            self.metadata.numberOfContacts += 1
        default:
            throw ChatExtractorError.attachmentNotSupported
        }
        
        return (attachment, attachmentExtension, messageType)
    }
    
    private func parseFileMessage(fileMatch: Regex<(Substring, Substring, Substring)>.Match) throws -> (filename: String, fileURL: URL) {
        let fileURL = self.chatDataURL.appendingPathComponent(String(fileMatch.2))
        if !fileURL.isFileURL {
            throw ChatExtractorError.fileNotExist
        }
        return (String(fileMatch.1), fileURL)
    }
    
    private func parsePollMessage(pollMatch: Regex<(Substring, Substring, Substring)>.Match) throws -> (question: String, options: [WhatsAppPollOption]) {
        var pollOptions = [WhatsAppPollOption]()
        let pollOptionLines = pollMatch.2.split(whereSeparator: { $0.isNewline })
        for line in pollOptionLines {
            do {
                guard let pollOptionMatch = try WhatsAppConstants.pollOptionPattern.wholeMatch(in: line) else {
                    throw ChatExtractorError.messageNotValid
                }
                guard let voteCount = Int(pollOptionMatch.2) else {
                    throw ChatExtractorError.messageNotValid
                }
                pollOptions.append(WhatsAppPollOption(option: String(pollOptionMatch.1), count: voteCount))
            } catch {
                throw ChatExtractorError.messageNotValid
            }
        }
        return (String(pollMatch.1), pollOptions)
    }
}
